{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/lib/actions/setup.ts"],"sourcesContent":["\n\n\n'use server';\n\nimport type { InitialAdminData, User, Category, NewUserData, Product, Sale, CashOutflow, Inflow, Currency, CashTransfer, Company, UserRole, OrderItem, OrderDraft } from \"@/lib/types\";\nimport { adminDb, adminAuth } from \"../firebase/server\";\nimport { FieldValue } from \"firebase-admin/firestore\";\nimport { getFunctions, httpsCallable, HttpsCallable } from \"firebase/functions\";\nimport { reauthenticateWithCredential, EmailAuthProvider, signInWithEmailAndPassword } from \"firebase/auth\";\nimport { auth as clientAuth, app as clientApp } from \"../firebase/client\";\n\n// Cart type for server action\ntype PlainCartItem = {\n    id: string;\n    quantityInCart: number;\n    name: string;\n}\n\n\n// -----------------\n// Helpers Admin\n// -----------------\nconst getAdminDbOrThrow = () => {\n  if (!adminDb) throw new Error(\"La base de datos de administrador no está configurada.\");\n  return adminDb;\n};\n\nconst getAdminAuthOrThrow = () => {\n  if (!adminAuth) throw new Error(\"La autenticación de administrador no está configurada.\");\n  return adminAuth;\n};\n\nexport async function getCompanyIdForUser(userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const userRef = db.doc(`users/${userId}`);\n    const userSnap = await userRef.get();\n    if (!userSnap.exists || !userSnap.data()?.companyId) {\n        throw new Error(\"Usuario no asociado a ninguna empresa.\");\n    }\n    return userSnap.data()!.companyId;\n};\n\n// -----------------\n// Setup inicial\n// -----------------\nexport async function isInitialSetupRequired(): Promise<boolean> {\n  const db = getAdminDbOrThrow();\n  const companiesCol = db.collection(\"companies\");\n  const snapshot = await companiesCol.limit(1).get();\n  return snapshot.empty;\n};\n\nexport async function createInitialAdminUser(data: Omit<InitialAdminData, 'secretCode'>) {\n  const db = getAdminDbOrThrow();\n  const auth = getAdminAuthOrThrow();\n  const companyRef = db.collection(\"companies\").doc();\n  const userRecord = await auth.createUser({\n    email: data.email,\n    password: data.password,\n    displayName: data.adminName,\n  });\n\n  await auth.setCustomUserClaims(userRecord.uid, {\n    role: \"primary-admin\",\n    companyId: companyRef.id,\n  });\n\n  const batch = db.batch();\n\n  batch.set(companyRef, {\n    id: companyRef.id,\n    name: data.companyName,\n    ownerUid: userRecord.uid,\n    exchangeRate: 36.5,\n    pettyCashInitial: 0,\n    createdAt: FieldValue.serverTimestamp(),\n    logoUrl: \"\",\n    securityCodeSet: false, // Initialize security code status\n  });\n\n  const userRef = db.doc(`users/${userRecord.uid}`);\n  batch.set(userRef, {\n    uid: userRecord.uid,\n    name: data.adminName,\n    email: data.email,\n    role: \"primary-admin\",\n    companyId: companyRef.id,\n    createdAt: FieldValue.serverTimestamp(),\n  });\n\n  await batch.commit();\n\n  return { uid: userRecord.uid, companyId: companyRef.id };\n};\n\n// -----------------\n// Company Settings\n// -----------------\n\nexport async function updateCompanySettings(settings: Partial<Pick<Company, 'exchangeRate' | 'pettyCashInitial' | 'name' | 'logoUrl'>>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const companyRef = db.doc(`companies/${companyId}`);\n    \n    const validSettings: { [key: string]: any } = {};\n    if (typeof settings.exchangeRate === 'number') {\n        validSettings.exchangeRate = settings.exchangeRate;\n    }\n    if (typeof settings.pettyCashInitial === 'number') {\n        validSettings.pettyCashInitial = settings.pettyCashInitial;\n    }\n    if (typeof settings.name === 'string' && settings.name.length > 0) {\n        validSettings.name = settings.name;\n    }\n    if (typeof settings.logoUrl === 'string') {\n        validSettings.logoUrl = settings.logoUrl;\n    }\n\n    if (Object.keys(validSettings).length > 0) {\n        await companyRef.update(validSettings);\n    }\n}\n\n\n// -----------------\n// Gestión de usuarios\n// -----------------\nexport async function addUser(userData: NewUserData, adminUserId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(adminUserId);\n\n    if (userData.role !== 'admin' && userData.role !== 'employee') {\n        throw new Error(\"Rol de usuario no válido.\");\n    }\n\n    try {\n        const userRecord = await auth.createUser({\n            email: userData.email,\n            password: userData.password,\n            displayName: userData.name,\n        });\n        \n        await auth.setCustomUserClaims(userRecord.uid, { role: userData.role, companyId });\n\n        const newUserDocRef = db.doc(`users/${userRecord.uid}`);\n        await newUserDocRef.set({\n            uid: userRecord.uid,\n            name: userData.name,\n            email: userData.email,\n            role: userData.role,\n            companyId: companyId,\n            createdAt: FieldValue.serverTimestamp(),\n        });\n\n        return { uid: userRecord.uid };\n\n    } catch(error: any) {\n        if (error.code === 'auth/email-already-exists') {\n            throw new Error('Este correo electrónico ya está registrado.');\n        }\n        console.error(\"Error creating user:\", error);\n        throw new Error('No se pudo crear el usuario. ' + error.message);\n    }\n};\n\nexport async function updateUserRole(userIdToUpdate: string, newRole: UserRole, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n\n    const [companyId, { customClaims: adminClaims }] = await Promise.all([\n        getCompanyIdForUser(currentAdminId),\n        auth.getUser(currentAdminId),\n    ]);\n\n    if (newRole === 'primary-admin') {\n        throw new Error(\"La transferencia de propiedad debe hacerse a través de la acción 'transferPrimaryAdmin'.\");\n    }\n\n    const userToUpdateRef = db.doc(`users/${userIdToUpdate}`);\n    const userDoc = await userToUpdateRef.get();\n\n    if (!userDoc.exists || userDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario a modificar no pertenece a la misma empresa.\");\n    }\n\n    const targetUserRole = userDoc.data()?.role;\n\n    if (adminClaims?.role === 'admin' && (targetUserRole === 'admin' || targetUserRole === 'primary-admin')) {\n        throw new Error(\"Un administrador no puede modificar a otro administrador o al propietario.\");\n    }\n    \n    await auth.setCustomUserClaims(userIdToUpdate, { role: newRole, companyId });\n    await userToUpdateRef.update({ role: newRole });\n}\n\n\nexport async function transferPrimaryAdmin(targetUserId: string, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n\n    const { customClaims: adminClaims } = await auth.getUser(currentAdminId);\n\n    if (adminClaims?.role !== 'primary-admin') {\n        throw new Error(\"Solo el propietario actual puede transferir la propiedad.\");\n    }\n\n    const companyId = adminClaims.companyId;\n\n    const targetUserRef = db.doc(`users/${targetUserId}`);\n    const targetUserDoc = await targetUserRef.get();\n\n    if (!targetUserDoc.exists || targetUserDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario objetivo no pertenece a la misma empresa.\");\n    }\n    \n    const batch = db.batch();\n    const currentAdminUserRef = db.doc(`users/${currentAdminId}`);\n\n    // Update custom claims\n    await Promise.all([\n        auth.setCustomUserClaims(targetUserId, { role: 'primary-admin', companyId }),\n        auth.setCustomUserClaims(currentAdminId, { role: 'admin', companyId })\n    ]);\n    \n    // Update user documents in Firestore\n    batch.update(targetUserRef, { role: 'primary-admin' });\n    batch.update(currentAdminUserRef, { role: 'admin' });\n    \n    await batch.commit();\n}\n\n\nexport async function deleteUser(userIdToDelete: string, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(currentAdminId);\n\n    const userToDeleteRef = db.doc(`users/${userIdToDelete}`);\n    const userDoc = await userToDeleteRef.get();\n\n    if (!userDoc.exists || userDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario a eliminar no pertenece a tu empresa.\");\n    }\n\n    if (userDoc.data()?.role === 'primary-admin') {\n        throw new Error(\"No se puede eliminar al propietario de la empresa.\");\n    }\n\n    await auth.deleteUser(userIdToDelete);\n    await userToDeleteRef.delete();\n}\n\n\n// -----------------\n// Category Management\n// -----------------\nexport async function addCategory(categoryName: string, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const categoryCollection = db.collection(`companies/${companyId}/categories`);\n    \n    const existingCategoryQuery = await categoryCollection.where('name', '==', categoryName).limit(1).get();\n    if (!existingCategoryQuery.empty) {\n        return existingCategoryQuery.docs[0].id;\n    }\n    \n    const newCategoryRef = await categoryCollection.add({ name: categoryName });\n    return newCategoryRef.id;\n};\n\nexport async function deleteCategory(categoryId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    const categoryRef = db.doc(`companies/${companyId}/categories/${categoryId}`);\n    const productsRef = db.collection(`companies/${companyId}/products`);\n    \n    const productsQuery = productsRef.where('categoryId', '==', categoryId);\n    const productsSnapshot = await productsQuery.get();\n    \n    const batch = db.batch();\n    \n    productsSnapshot.forEach(doc => {\n      batch.update(doc.ref, { categoryId: \"\" });\n    });\n    \n    batch.delete(categoryRef);\n    \n    await batch.commit();\n};\n\n\n// -----------------\n// Product Management\n// -----------------\nexport async function addProduct(productData: Omit<Product, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productCollection = db.collection(`companies/${companyId}/products`);\n    await productCollection.add({\n        ...productData,\n        createdAt: FieldValue.serverTimestamp(),\n    });\n};\n\nexport async function addMultipleProducts(productsData: Omit<Product, 'id'>[], userId: string): Promise<{ successCount: number; errorCount: number; }> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productCollection = db.collection(`companies/${companyId}/products`);\n    \n    let successCount = 0;\n    let errorCount = 0;\n\n    const batchSize = 500;\n    for (let i = 0; i < productsData.length; i += batchSize) {\n        const batch = db.batch();\n        const chunk = productsData.slice(i, i + batchSize);\n        \n        for (const productData of chunk) {\n            try {\n                const docRef = productCollection.doc();\n                batch.set(docRef, { ...productData, createdAt: FieldValue.serverTimestamp() });\n                successCount++;\n            } catch (e) {\n                console.error(\"Error adding product to batch:\", productData.name, e);\n                errorCount++;\n            }\n        }\n        await batch.commit();\n    }\n\n    return { successCount, errorCount };\n}\n\n\nexport async function updateProduct(productId: string, productData: Partial<Product>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n    await productRef.update(productData);\n};\n\nexport async function deleteProduct(productId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n    await productRef.delete();\n};\n\n\n// -----------------\n// Order Draft Management\n// -----------------\nexport async function addOrderDraft(title: string, items: OrderItem[], totalCost: number, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const draftsCollection = db.collection(`companies/${companyId}/orderDrafts`);\n    await draftsCollection.add({\n        title,\n        items,\n        totalCost,\n        status: 'draft',\n        createdAt: FieldValue.serverTimestamp(),\n    });\n}\n\nexport async function deleteOrderDraft(draftId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const draftRef = db.doc(`companies/${companyId}/orderDrafts/${draftId}`);\n    await draftRef.delete();\n}\n\nexport async function restockInventory(drafts: OrderDraft[], userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n\n    const consolidatedItems = new Map<string, number>();\n    let totalCost = 0;\n    \n    drafts.forEach(draft => {\n        totalCost += draft.totalCost;\n        draft.items.forEach(item => {\n            consolidatedItems.set(item.productId, (consolidatedItems.get(item.productId) || 0) + item.orderQuantity);\n        });\n    });\n\n    const newOutflow: Omit<CashOutflow, 'id'> = {\n        date: new Date().toISOString(),\n        amount: totalCost,\n        currency: 'NIO', // Assuming restock is always in NIO\n        cashBox: 'general',\n        reason: `Abastecimiento de inventario (${drafts.length} borrador/es)`,\n        type: 'restock',\n    };\n\n    const outflowId = await db.runTransaction(async (transaction) => {\n        // --- READS ---\n        const productRefs = Array.from(consolidatedItems.keys()).map(productId => db.doc(`companies/${companyId}/products/${productId}`));\n        const productDocs = productRefs.length > 0 ? await transaction.getAll(...productRefs) : [];\n        const productsToUpdate: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (const productDoc of productDocs) {\n            const orderQuantity = consolidatedItems.get(productDoc.id);\n            if (productDoc.exists && orderQuantity) {\n                const currentStock = productDoc.data()?.quantity || 0;\n                const newStock = currentStock + orderQuantity;\n                productsToUpdate.push({ ref: productDoc.ref, newStock });\n            }\n        }\n        \n        // --- WRITES ---\n        // 1. Create the cash outflow document\n        const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n        transaction.set(outflowRef, newOutflow);\n        \n        // 2. Update stock for all products\n        productsToUpdate.forEach(p => {\n            transaction.update(p.ref, { quantity: p.newStock });\n        });\n\n        // 3. Mark drafts as completed\n        drafts.forEach(draft => {\n            const draftRef = db.doc(`companies/${companyId}/orderDrafts/${draft.id}`);\n            transaction.update(draftRef, { status: 'completed' });\n        });\n        \n        return outflowRef.id;\n    });\n\n    return outflowId;\n}\n\n\n// -----------------\n// Sales Management\n// -----------------\nexport async function addSale(newSale: Omit<Sale, 'id' | 'reviewNotes'>, cart: PlainCartItem[], userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    const saleId = await db.runTransaction(async (transaction) => {\n        // --- 1. READS ---\n        const productRefs = cart.map(item => db.doc(`companies/${companyId}/products/${item.id}`));\n        const productDocs = productRefs.length > 0 ? await transaction.getAll(...productRefs) : [];\n        const productsToUpdate: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (let i = 0; i < productDocs.length; i++) {\n            const productDoc = productDocs[i];\n            const cartItem = cart[i];\n\n            if (!productDoc.exists) {\n                throw new Error(`Producto con ID ${cartItem.id} no encontrado.`);\n            }\n\n            const currentStock = productDoc.data()?.quantity || 0;\n            const newStock = currentStock - cartItem.quantityInCart;\n\n            if (newStock < 0) {\n                throw new Error(`Stock insuficiente para ${productDoc.data()?.name}.`);\n            }\n            productsToUpdate.push({ ref: productDoc.ref, newStock });\n        }\n\n        // --- 2. WRITES ---\n        const salesCollection = db.collection(`companies/${companyId}/sales`);\n        const saleRef = salesCollection.doc();\n        transaction.set(saleRef, newSale);\n\n        productsToUpdate.forEach(p => {\n            transaction.update(p.ref, { quantity: p.newStock });\n        });\n        \n        return saleRef.id;\n    });\n\n    return saleId;\n};\n\nexport async function updateSaleAndAdjustStock(updatedSale: Sale, originalSale: Sale, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    await db.runTransaction(async (transaction) => {\n        const saleRef = db.doc(`companies/${companyId}/sales/${updatedSale.id}`);\n        const productQuantityChanges: { [productId: string]: number } = {};\n\n        // Calculate deltas: Positive value means stock should increase (product returned)\n        originalSale.items.forEach(item => {\n            productQuantityChanges[item.productId] = (productQuantityChanges[item.productId] || 0) + item.quantity;\n        });\n\n        updatedSale.items.forEach(item => {\n            productQuantityChanges[item.productId] = (productQuantityChanges[item.productId] || 0) - item.quantity;\n        });\n\n        // --- READS ---\n        const productRefsToRead = Object.keys(productQuantityChanges)\n            .filter(productId => productQuantityChanges[productId] !== 0)\n            .map(productId => db.doc(`companies/${companyId}/products/${productId}`));\n        \n        const productDocs = productRefsToRead.length > 0 ? await transaction.getAll(...productRefsToRead) : [];\n        \n        // --- WRITES ---\n        const updates: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (const productDoc of productDocs) {\n            if (!productDoc.exists) continue; // Skip if product somehow got deleted\n            const productId = productDoc.id;\n            const delta = productQuantityChanges[productId];\n            const currentStock = productDoc.data()?.quantity || 0;\n            const newStock = currentStock + delta;\n\n            if (newStock < 0) {\n                const productName = productDoc.data()?.name || productId;\n                throw new Error(`No se puede completar la actualización. El stock de \"${productName}\" sería negativo.`);\n            }\n            updates.push({ ref: productDoc.ref, newStock });\n        }\n\n        // Create refund outflow if necessary\n        const refundAmount = originalSale.grandTotal - updatedSale.grandTotal;\n        if (refundAmount > 0) {\n            const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n            transaction.set(outflowRef, {\n                date: new Date().toISOString(),\n                amount: refundAmount,\n                currency: originalSale.paymentCurrency,\n                cashBox: 'general',\n                reason: `Ajuste/reembolso de Venta ID: ${originalSale.id.substring(0,8)}...`,\n                type: 'adjustment' as const,\n            });\n        }\n        \n        // Update the sale document\n        transaction.update(saleRef, {\n            items: updatedSale.items,\n            grandTotal: updatedSale.grandTotal,\n            needsReview: false,\n            reviewNotes: FieldValue.delete() // Remove notes after review\n        });\n\n        // Apply stock updates\n        updates.forEach(update => {\n            transaction.update(update.ref, { quantity: update.newStock });\n        });\n    });\n};\n\nexport async function markSaleForReview(saleId: string, notes: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const saleRef = db.doc(`companies/${companyId}/sales/${saleId}`);\n    await saleRef.update({ needsReview: true, reviewNotes: notes });\n}\n\n// -----------------\n// Inventory Loss Management\n// -----------------\n\nexport async function adjustStockForLoss(productId: string, lostQuantity: number, reason: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n\n    await db.runTransaction(async (transaction) => {\n        const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n        const productDoc = await transaction.get(productRef);\n\n        if (!productDoc.exists) {\n            throw new Error(\"El producto que intentas ajustar no existe.\");\n        }\n\n        const productData = productDoc.data() as Product;\n        const currentStock = productData.quantity;\n        const newStock = currentStock - lostQuantity;\n\n        if (newStock < 0) {\n            throw new Error(`La cantidad a dar de baja (${lostQuantity}) es mayor que el stock actual (${currentStock}).`);\n        }\n\n        const lossValue = productData.purchaseCost * lostQuantity;\n\n        const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n        transaction.set(outflowRef, {\n            date: new Date().toISOString(),\n            amount: lossValue,\n            currency: 'NIO', // Losses are always calculated in base currency\n            cashBox: 'general', // This is a virtual outflow from 'general' box\n            reason: `Pérdida de ${lostQuantity} ${productData.stockingUnit} de \"${productData.name}\": ${reason}`,\n            type: 'loss' as const,\n        });\n\n        transaction.update(productRef, { quantity: newStock });\n    });\n}\n\n\n// -----------------\n// Cash Flow & Reconciliation\n// -----------------\n\nexport async function addCashOutflow(outflow: Omit<CashOutflow, 'id'>, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const outflowsCollection = db.collection(`companies/${companyId}/cash_outflows`);\n    const docRef = await outflowsCollection.add(outflow);\n    return docRef.id;\n};\n\nexport async function addWithdrawal(withdrawalData: Omit<CashOutflow, 'id'>, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const outflowsCollection = db.collection(`companies/${companyId}/cash_outflows`);\n    \n    const outflowToCreate: Omit<CashOutflow, 'id'> = {\n        ...withdrawalData,\n        type: 'withdrawal',\n    };\n\n    const docRef = await outflowsCollection.add(outflowToCreate);\n    return docRef.id;\n}\n\nexport async function addInflow(inflow: Omit<Inflow, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const inflowsCollection = db.collection(`companies/${companyId}/inflows`);\n    await inflowsCollection.add(inflow);\n};\n\nexport async function addCashTransfer(transfer: Omit<CashTransfer, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const transfersCollection = db.collection(`companies/${companyId}/cash_transfers`);\n    await transfersCollection.add(transfer);\n};\n\nexport async function updateReconciliationStatus(dateId: string, status: 'open' | 'closed', userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const reconRef = db.doc(`companies/${companyId}/reconciliations/${dateId}`);\n    await reconRef.set({\n        status: status,\n        updatedAt: FieldValue.serverTimestamp()\n    }, { merge: true });\n};\n\n\n// -----------------\n// Danger Zone\n// -----------------\n\nexport async function setCompanySecurityCode(password: string, securityCode: string, userId: string): Promise<void> {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    \n    const { customClaims, email } = await auth.getUser(userId);\n\n    if (customClaims?.role !== 'primary-admin' || !email) {\n        throw new Error(\"Solo el propietario puede configurar un código de seguridad.\");\n    }\n    \n    try {\n        if (!clientAuth.currentUser) {\n            await signInWithEmailAndPassword(clientAuth, email, password);\n        }\n        const userCredential = EmailAuthProvider.credential(email, password);\n        await reauthenticateWithCredential(clientAuth.currentUser!, userCredential);\n    } catch(e) {\n        throw new Error(\"No se pudo reautenticar. La contraseña actual es incorrecta.\");\n    }\n\n    const companyId = await getCompanyIdForUser(userId);\n    const companyRef = db.doc(`companies/${companyId}`);\n    const securityDocRef = db.doc(`companies/${companyId}/private/security`);\n\n    await securityDocRef.set({ code: securityCode });\n    await companyRef.update({ securityCodeSet: true });\n}\n\nexport async function initiateCompanyWipe(password: string, securityCode: string, userId: string): Promise<any> {\n    const auth = getAdminAuthOrThrow();\n    const { email } = await auth.getUser(userId);\n    \n    if (!email) {\n        throw new Error(\"El usuario no tiene un email para reautenticar.\");\n    }\n\n    try {\n        if (!clientAuth.currentUser) {\n           await signInWithEmailAndPassword(clientAuth, email, password);\n        }\n        const userCredential = EmailAuthProvider.credential(email, password);\n        await reauthenticateWithCredential(clientAuth.currentUser!, userCredential);\n    } catch(e) {\n        throw new Error(\"No se pudo reautenticar. La contraseña actual es incorrecta.\");\n    }\n\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const securityDocRef = db.doc(`companies/${companyId}/private/security`);\n    const securityDoc = await securityDocRef.get();\n    \n    if (!securityDoc.exists || securityDoc.data()?.code !== securityCode) {\n        throw new Error(\"El código de seguridad es incorrecto.\");\n    }\n    \n    const functions = getFunctions(clientApp);\n    const wipeCompanyData: HttpsCallable = httpsCallable(functions, 'wipeCompanyData');\n\n    try {\n        const result = await wipeCompanyData();\n        return result.data;\n    } catch (error: any) {\n        console.error(\"Error al invocar la función de borrado:\", error);\n        throw new Error(error.message || \"Error desconocido al llamar a la función de borrado.\");\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA8CsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/lib/actions/setup.ts"],"sourcesContent":["\n\n\n'use server';\n\nimport type { InitialAdminData, User, Category, NewUserData, Product, Sale, CashOutflow, Inflow, Currency, CashTransfer, Company, UserRole, OrderItem, OrderDraft } from \"@/lib/types\";\nimport { adminDb, adminAuth } from \"../firebase/server\";\nimport { FieldValue } from \"firebase-admin/firestore\";\nimport { getFunctions, httpsCallable, HttpsCallable } from \"firebase/functions\";\nimport { reauthenticateWithCredential, EmailAuthProvider, signInWithEmailAndPassword } from \"firebase/auth\";\nimport { auth as clientAuth, app as clientApp } from \"../firebase/client\";\n\n// Cart type for server action\ntype PlainCartItem = {\n    id: string;\n    quantityInCart: number;\n    name: string;\n}\n\n\n// -----------------\n// Helpers Admin\n// -----------------\nconst getAdminDbOrThrow = () => {\n  if (!adminDb) throw new Error(\"La base de datos de administrador no está configurada.\");\n  return adminDb;\n};\n\nconst getAdminAuthOrThrow = () => {\n  if (!adminAuth) throw new Error(\"La autenticación de administrador no está configurada.\");\n  return adminAuth;\n};\n\nexport async function getCompanyIdForUser(userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const userRef = db.doc(`users/${userId}`);\n    const userSnap = await userRef.get();\n    if (!userSnap.exists || !userSnap.data()?.companyId) {\n        throw new Error(\"Usuario no asociado a ninguna empresa.\");\n    }\n    return userSnap.data()!.companyId;\n};\n\n// -----------------\n// Setup inicial\n// -----------------\nexport async function isInitialSetupRequired(): Promise<boolean> {\n  const db = getAdminDbOrThrow();\n  const companiesCol = db.collection(\"companies\");\n  const snapshot = await companiesCol.limit(1).get();\n  return snapshot.empty;\n};\n\nexport async function createInitialAdminUser(data: Omit<InitialAdminData, 'secretCode'>) {\n  const db = getAdminDbOrThrow();\n  const auth = getAdminAuthOrThrow();\n  const companyRef = db.collection(\"companies\").doc();\n  const userRecord = await auth.createUser({\n    email: data.email,\n    password: data.password,\n    displayName: data.adminName,\n  });\n\n  await auth.setCustomUserClaims(userRecord.uid, {\n    role: \"primary-admin\",\n    companyId: companyRef.id,\n  });\n\n  const batch = db.batch();\n\n  batch.set(companyRef, {\n    id: companyRef.id,\n    name: data.companyName,\n    ownerUid: userRecord.uid,\n    exchangeRate: 36.5,\n    pettyCashInitial: 0,\n    createdAt: FieldValue.serverTimestamp(),\n    logoUrl: \"\",\n    securityCodeSet: false, // Initialize security code status\n  });\n\n  const userRef = db.doc(`users/${userRecord.uid}`);\n  batch.set(userRef, {\n    uid: userRecord.uid,\n    name: data.adminName,\n    email: data.email,\n    role: \"primary-admin\",\n    companyId: companyRef.id,\n    createdAt: FieldValue.serverTimestamp(),\n  });\n\n  await batch.commit();\n\n  return { uid: userRecord.uid, companyId: companyRef.id };\n};\n\n// -----------------\n// Company Settings\n// -----------------\n\nexport async function updateCompanySettings(settings: Partial<Pick<Company, 'exchangeRate' | 'pettyCashInitial' | 'name' | 'logoUrl'>>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const companyRef = db.doc(`companies/${companyId}`);\n    \n    const validSettings: { [key: string]: any } = {};\n    if (typeof settings.exchangeRate === 'number') {\n        validSettings.exchangeRate = settings.exchangeRate;\n    }\n    if (typeof settings.pettyCashInitial === 'number') {\n        validSettings.pettyCashInitial = settings.pettyCashInitial;\n    }\n    if (typeof settings.name === 'string' && settings.name.length > 0) {\n        validSettings.name = settings.name;\n    }\n    if (typeof settings.logoUrl === 'string') {\n        validSettings.logoUrl = settings.logoUrl;\n    }\n\n    if (Object.keys(validSettings).length > 0) {\n        await companyRef.update(validSettings);\n    }\n}\n\n\n// -----------------\n// Gestión de usuarios\n// -----------------\nexport async function addUser(userData: NewUserData, adminUserId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(adminUserId);\n\n    if (userData.role !== 'admin' && userData.role !== 'employee') {\n        throw new Error(\"Rol de usuario no válido.\");\n    }\n\n    try {\n        const userRecord = await auth.createUser({\n            email: userData.email,\n            password: userData.password,\n            displayName: userData.name,\n        });\n        \n        await auth.setCustomUserClaims(userRecord.uid, { role: userData.role, companyId });\n\n        const newUserDocRef = db.doc(`users/${userRecord.uid}`);\n        await newUserDocRef.set({\n            uid: userRecord.uid,\n            name: userData.name,\n            email: userData.email,\n            role: userData.role,\n            companyId: companyId,\n            createdAt: FieldValue.serverTimestamp(),\n        });\n\n        return { uid: userRecord.uid };\n\n    } catch(error: any) {\n        if (error.code === 'auth/email-already-exists') {\n            throw new Error('Este correo electrónico ya está registrado.');\n        }\n        console.error(\"Error creating user:\", error);\n        throw new Error('No se pudo crear el usuario. ' + error.message);\n    }\n};\n\nexport async function updateUserRole(userIdToUpdate: string, newRole: UserRole, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n\n    const [companyId, { customClaims: adminClaims }] = await Promise.all([\n        getCompanyIdForUser(currentAdminId),\n        auth.getUser(currentAdminId),\n    ]);\n\n    if (newRole === 'primary-admin') {\n        throw new Error(\"La transferencia de propiedad debe hacerse a través de la acción 'transferPrimaryAdmin'.\");\n    }\n\n    const userToUpdateRef = db.doc(`users/${userIdToUpdate}`);\n    const userDoc = await userToUpdateRef.get();\n\n    if (!userDoc.exists || userDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario a modificar no pertenece a la misma empresa.\");\n    }\n\n    const targetUserRole = userDoc.data()?.role;\n\n    if (adminClaims?.role === 'admin' && (targetUserRole === 'admin' || targetUserRole === 'primary-admin')) {\n        throw new Error(\"Un administrador no puede modificar a otro administrador o al propietario.\");\n    }\n    \n    await auth.setCustomUserClaims(userIdToUpdate, { role: newRole, companyId });\n    await userToUpdateRef.update({ role: newRole });\n}\n\n\nexport async function transferPrimaryAdmin(targetUserId: string, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n\n    const { customClaims: adminClaims } = await auth.getUser(currentAdminId);\n\n    if (adminClaims?.role !== 'primary-admin') {\n        throw new Error(\"Solo el propietario actual puede transferir la propiedad.\");\n    }\n\n    const companyId = adminClaims.companyId;\n\n    const targetUserRef = db.doc(`users/${targetUserId}`);\n    const targetUserDoc = await targetUserRef.get();\n\n    if (!targetUserDoc.exists || targetUserDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario objetivo no pertenece a la misma empresa.\");\n    }\n    \n    const batch = db.batch();\n    const currentAdminUserRef = db.doc(`users/${currentAdminId}`);\n\n    // Update custom claims\n    await Promise.all([\n        auth.setCustomUserClaims(targetUserId, { role: 'primary-admin', companyId }),\n        auth.setCustomUserClaims(currentAdminId, { role: 'admin', companyId })\n    ]);\n    \n    // Update user documents in Firestore\n    batch.update(targetUserRef, { role: 'primary-admin' });\n    batch.update(currentAdminUserRef, { role: 'admin' });\n    \n    await batch.commit();\n}\n\n\nexport async function deleteUser(userIdToDelete: string, currentAdminId: string) {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(currentAdminId);\n\n    const userToDeleteRef = db.doc(`users/${userIdToDelete}`);\n    const userDoc = await userToDeleteRef.get();\n\n    if (!userDoc.exists || userDoc.data()?.companyId !== companyId) {\n        throw new Error(\"El usuario a eliminar no pertenece a tu empresa.\");\n    }\n\n    if (userDoc.data()?.role === 'primary-admin') {\n        throw new Error(\"No se puede eliminar al propietario de la empresa.\");\n    }\n\n    await auth.deleteUser(userIdToDelete);\n    await userToDeleteRef.delete();\n}\n\n\n// -----------------\n// Category Management\n// -----------------\nexport async function addCategory(categoryName: string, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const categoryCollection = db.collection(`companies/${companyId}/categories`);\n    \n    const existingCategoryQuery = await categoryCollection.where('name', '==', categoryName).limit(1).get();\n    if (!existingCategoryQuery.empty) {\n        return existingCategoryQuery.docs[0].id;\n    }\n    \n    const newCategoryRef = await categoryCollection.add({ name: categoryName });\n    return newCategoryRef.id;\n};\n\nexport async function deleteCategory(categoryId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    const categoryRef = db.doc(`companies/${companyId}/categories/${categoryId}`);\n    const productsRef = db.collection(`companies/${companyId}/products`);\n    \n    const productsQuery = productsRef.where('categoryId', '==', categoryId);\n    const productsSnapshot = await productsQuery.get();\n    \n    const batch = db.batch();\n    \n    productsSnapshot.forEach(doc => {\n      batch.update(doc.ref, { categoryId: \"\" });\n    });\n    \n    batch.delete(categoryRef);\n    \n    await batch.commit();\n};\n\n\n// -----------------\n// Product Management\n// -----------------\nexport async function addProduct(productData: Omit<Product, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productCollection = db.collection(`companies/${companyId}/products`);\n    await productCollection.add({\n        ...productData,\n        createdAt: FieldValue.serverTimestamp(),\n    });\n};\n\nexport async function addMultipleProducts(productsData: Omit<Product, 'id'>[], userId: string): Promise<{ successCount: number; errorCount: number; }> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productCollection = db.collection(`companies/${companyId}/products`);\n    \n    let successCount = 0;\n    let errorCount = 0;\n\n    const batchSize = 500;\n    for (let i = 0; i < productsData.length; i += batchSize) {\n        const batch = db.batch();\n        const chunk = productsData.slice(i, i + batchSize);\n        \n        for (const productData of chunk) {\n            try {\n                const docRef = productCollection.doc();\n                batch.set(docRef, { ...productData, createdAt: FieldValue.serverTimestamp() });\n                successCount++;\n            } catch (e) {\n                console.error(\"Error adding product to batch:\", productData.name, e);\n                errorCount++;\n            }\n        }\n        await batch.commit();\n    }\n\n    return { successCount, errorCount };\n}\n\n\nexport async function updateProduct(productId: string, productData: Partial<Product>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n    await productRef.update(productData);\n};\n\nexport async function deleteProduct(productId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n    await productRef.delete();\n};\n\n\n// -----------------\n// Order Draft Management\n// -----------------\nexport async function addOrderDraft(title: string, items: OrderItem[], totalCost: number, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const draftsCollection = db.collection(`companies/${companyId}/orderDrafts`);\n    await draftsCollection.add({\n        title,\n        items,\n        totalCost,\n        status: 'draft',\n        createdAt: FieldValue.serverTimestamp(),\n    });\n}\n\nexport async function deleteOrderDraft(draftId: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const draftRef = db.doc(`companies/${companyId}/orderDrafts/${draftId}`);\n    await draftRef.delete();\n}\n\nexport async function restockInventory(drafts: OrderDraft[], userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n\n    const consolidatedItems = new Map<string, number>();\n    let totalCost = 0;\n    \n    drafts.forEach(draft => {\n        totalCost += draft.totalCost;\n        draft.items.forEach(item => {\n            consolidatedItems.set(item.productId, (consolidatedItems.get(item.productId) || 0) + item.orderQuantity);\n        });\n    });\n\n    const newOutflow: Omit<CashOutflow, 'id'> = {\n        date: new Date().toISOString(),\n        amount: totalCost,\n        currency: 'NIO', // Assuming restock is always in NIO\n        cashBox: 'general',\n        reason: `Abastecimiento de inventario (${drafts.length} borrador/es)`,\n        type: 'restock',\n    };\n\n    const outflowId = await db.runTransaction(async (transaction) => {\n        // --- READS ---\n        const productRefs = Array.from(consolidatedItems.keys()).map(productId => db.doc(`companies/${companyId}/products/${productId}`));\n        const productDocs = productRefs.length > 0 ? await transaction.getAll(...productRefs) : [];\n        const productsToUpdate: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (const productDoc of productDocs) {\n            const orderQuantity = consolidatedItems.get(productDoc.id);\n            if (productDoc.exists && orderQuantity) {\n                const currentStock = productDoc.data()?.quantity || 0;\n                const newStock = currentStock + orderQuantity;\n                productsToUpdate.push({ ref: productDoc.ref, newStock });\n            }\n        }\n        \n        // --- WRITES ---\n        // 1. Create the cash outflow document\n        const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n        transaction.set(outflowRef, newOutflow);\n        \n        // 2. Update stock for all products\n        productsToUpdate.forEach(p => {\n            transaction.update(p.ref, { quantity: p.newStock });\n        });\n\n        // 3. Mark drafts as completed\n        drafts.forEach(draft => {\n            const draftRef = db.doc(`companies/${companyId}/orderDrafts/${draft.id}`);\n            transaction.update(draftRef, { status: 'completed' });\n        });\n        \n        return outflowRef.id;\n    });\n\n    return outflowId;\n}\n\n\n// -----------------\n// Sales Management\n// -----------------\nexport async function addSale(newSale: Omit<Sale, 'id' | 'reviewNotes'>, cart: PlainCartItem[], userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    const saleId = await db.runTransaction(async (transaction) => {\n        // --- 1. READS ---\n        const productRefs = cart.map(item => db.doc(`companies/${companyId}/products/${item.id}`));\n        const productDocs = productRefs.length > 0 ? await transaction.getAll(...productRefs) : [];\n        const productsToUpdate: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (let i = 0; i < productDocs.length; i++) {\n            const productDoc = productDocs[i];\n            const cartItem = cart[i];\n\n            if (!productDoc.exists) {\n                throw new Error(`Producto con ID ${cartItem.id} no encontrado.`);\n            }\n\n            const currentStock = productDoc.data()?.quantity || 0;\n            const newStock = currentStock - cartItem.quantityInCart;\n\n            if (newStock < 0) {\n                throw new Error(`Stock insuficiente para ${productDoc.data()?.name}.`);\n            }\n            productsToUpdate.push({ ref: productDoc.ref, newStock });\n        }\n\n        // --- 2. WRITES ---\n        const salesCollection = db.collection(`companies/${companyId}/sales`);\n        const saleRef = salesCollection.doc();\n        transaction.set(saleRef, newSale);\n\n        productsToUpdate.forEach(p => {\n            transaction.update(p.ref, { quantity: p.newStock });\n        });\n        \n        return saleRef.id;\n    });\n\n    return saleId;\n};\n\nexport async function updateSaleAndAdjustStock(updatedSale: Sale, originalSale: Sale, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    \n    await db.runTransaction(async (transaction) => {\n        const saleRef = db.doc(`companies/${companyId}/sales/${updatedSale.id}`);\n        const productQuantityChanges: { [productId: string]: number } = {};\n\n        // Calculate deltas: Positive value means stock should increase (product returned)\n        originalSale.items.forEach(item => {\n            productQuantityChanges[item.productId] = (productQuantityChanges[item.productId] || 0) + item.quantity;\n        });\n\n        updatedSale.items.forEach(item => {\n            productQuantityChanges[item.productId] = (productQuantityChanges[item.productId] || 0) - item.quantity;\n        });\n\n        // --- READS ---\n        const productRefsToRead = Object.keys(productQuantityChanges)\n            .filter(productId => productQuantityChanges[productId] !== 0)\n            .map(productId => db.doc(`companies/${companyId}/products/${productId}`));\n        \n        const productDocs = productRefsToRead.length > 0 ? await transaction.getAll(...productRefsToRead) : [];\n        \n        // --- WRITES ---\n        const updates: { ref: FirebaseFirestore.DocumentReference, newStock: number }[] = [];\n\n        for (const productDoc of productDocs) {\n            if (!productDoc.exists) continue; // Skip if product somehow got deleted\n            const productId = productDoc.id;\n            const delta = productQuantityChanges[productId];\n            const currentStock = productDoc.data()?.quantity || 0;\n            const newStock = currentStock + delta;\n\n            if (newStock < 0) {\n                const productName = productDoc.data()?.name || productId;\n                throw new Error(`No se puede completar la actualización. El stock de \"${productName}\" sería negativo.`);\n            }\n            updates.push({ ref: productDoc.ref, newStock });\n        }\n\n        // Create refund outflow if necessary\n        const refundAmount = originalSale.grandTotal - updatedSale.grandTotal;\n        if (refundAmount > 0) {\n            const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n            transaction.set(outflowRef, {\n                date: new Date().toISOString(),\n                amount: refundAmount,\n                currency: originalSale.paymentCurrency,\n                cashBox: 'general',\n                reason: `Ajuste/reembolso de Venta ID: ${originalSale.id.substring(0,8)}...`,\n                type: 'adjustment' as const,\n            });\n        }\n        \n        // Update the sale document\n        transaction.update(saleRef, {\n            items: updatedSale.items,\n            grandTotal: updatedSale.grandTotal,\n            needsReview: false,\n            reviewNotes: FieldValue.delete() // Remove notes after review\n        });\n\n        // Apply stock updates\n        updates.forEach(update => {\n            transaction.update(update.ref, { quantity: update.newStock });\n        });\n    });\n};\n\nexport async function markSaleForReview(saleId: string, notes: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const saleRef = db.doc(`companies/${companyId}/sales/${saleId}`);\n    await saleRef.update({ needsReview: true, reviewNotes: notes });\n}\n\n// -----------------\n// Inventory Loss Management\n// -----------------\n\nexport async function adjustStockForLoss(productId: string, lostQuantity: number, reason: string, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n\n    await db.runTransaction(async (transaction) => {\n        const productRef = db.doc(`companies/${companyId}/products/${productId}`);\n        const productDoc = await transaction.get(productRef);\n\n        if (!productDoc.exists) {\n            throw new Error(\"El producto que intentas ajustar no existe.\");\n        }\n\n        const productData = productDoc.data() as Product;\n        const currentStock = productData.quantity;\n        const newStock = currentStock - lostQuantity;\n\n        if (newStock < 0) {\n            throw new Error(`La cantidad a dar de baja (${lostQuantity}) es mayor que el stock actual (${currentStock}).`);\n        }\n\n        const lossValue = productData.purchaseCost * lostQuantity;\n\n        const outflowRef = db.collection(`companies/${companyId}/cash_outflows`).doc();\n        transaction.set(outflowRef, {\n            date: new Date().toISOString(),\n            amount: lossValue,\n            currency: 'NIO', // Losses are always calculated in base currency\n            cashBox: 'general', // This is a virtual outflow from 'general' box\n            reason: `Pérdida de ${lostQuantity} ${productData.stockingUnit} de \"${productData.name}\": ${reason}`,\n            type: 'loss' as const,\n        });\n\n        transaction.update(productRef, { quantity: newStock });\n    });\n}\n\n\n// -----------------\n// Cash Flow & Reconciliation\n// -----------------\n\nexport async function addCashOutflow(outflow: Omit<CashOutflow, 'id'>, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const outflowsCollection = db.collection(`companies/${companyId}/cash_outflows`);\n    const docRef = await outflowsCollection.add(outflow);\n    return docRef.id;\n};\n\nexport async function addWithdrawal(withdrawalData: Omit<CashOutflow, 'id'>, userId: string): Promise<string> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const outflowsCollection = db.collection(`companies/${companyId}/cash_outflows`);\n    \n    const outflowToCreate: Omit<CashOutflow, 'id'> = {\n        ...withdrawalData,\n        type: 'withdrawal',\n    };\n\n    const docRef = await outflowsCollection.add(outflowToCreate);\n    return docRef.id;\n}\n\nexport async function addInflow(inflow: Omit<Inflow, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const inflowsCollection = db.collection(`companies/${companyId}/inflows`);\n    await inflowsCollection.add(inflow);\n};\n\nexport async function addCashTransfer(transfer: Omit<CashTransfer, 'id'>, userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const transfersCollection = db.collection(`companies/${companyId}/cash_transfers`);\n    await transfersCollection.add(transfer);\n};\n\nexport async function updateReconciliationStatus(dateId: string, status: 'open' | 'closed', userId: string): Promise<void> {\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const reconRef = db.doc(`companies/${companyId}/reconciliations/${dateId}`);\n    await reconRef.set({\n        status: status,\n        updatedAt: FieldValue.serverTimestamp()\n    }, { merge: true });\n};\n\n\n// -----------------\n// Danger Zone\n// -----------------\n\nexport async function setCompanySecurityCode(password: string, securityCode: string, userId: string): Promise<void> {\n    const auth = getAdminAuthOrThrow();\n    const db = getAdminDbOrThrow();\n    \n    const { customClaims, email } = await auth.getUser(userId);\n\n    if (customClaims?.role !== 'primary-admin' || !email) {\n        throw new Error(\"Solo el propietario puede configurar un código de seguridad.\");\n    }\n    \n    try {\n        if (!clientAuth.currentUser) {\n            await signInWithEmailAndPassword(clientAuth, email, password);\n        }\n        const userCredential = EmailAuthProvider.credential(email, password);\n        await reauthenticateWithCredential(clientAuth.currentUser!, userCredential);\n    } catch(e) {\n        throw new Error(\"No se pudo reautenticar. La contraseña actual es incorrecta.\");\n    }\n\n    const companyId = await getCompanyIdForUser(userId);\n    const companyRef = db.doc(`companies/${companyId}`);\n    const securityDocRef = db.doc(`companies/${companyId}/private/security`);\n\n    await securityDocRef.set({ code: securityCode });\n    await companyRef.update({ securityCodeSet: true });\n}\n\nexport async function initiateCompanyWipe(password: string, securityCode: string, userId: string): Promise<any> {\n    const auth = getAdminAuthOrThrow();\n    const { email } = await auth.getUser(userId);\n    \n    if (!email) {\n        throw new Error(\"El usuario no tiene un email para reautenticar.\");\n    }\n\n    try {\n        if (!clientAuth.currentUser) {\n           await signInWithEmailAndPassword(clientAuth, email, password);\n        }\n        const userCredential = EmailAuthProvider.credential(email, password);\n        await reauthenticateWithCredential(clientAuth.currentUser!, userCredential);\n    } catch(e) {\n        throw new Error(\"No se pudo reautenticar. La contraseña actual es incorrecta.\");\n    }\n\n    const db = getAdminDbOrThrow();\n    const companyId = await getCompanyIdForUser(userId);\n    const securityDocRef = db.doc(`companies/${companyId}/private/security`);\n    const securityDoc = await securityDocRef.get();\n    \n    if (!securityDoc.exists || securityDoc.data()?.code !== securityCode) {\n        throw new Error(\"El código de seguridad es incorrecto.\");\n    }\n    \n    const functions = getFunctions(clientApp);\n    const wipeCompanyData: HttpsCallable = httpsCallable(functions, 'wipeCompanyData');\n\n    try {\n        const result = await wipeCompanyData();\n        return result.data;\n    } catch (error: any) {\n        console.error(\"Error al invocar la función de borrado:\", error);\n        throw new Error(error.message || \"Error desconocido al llamar a la función de borrado.\");\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAqDsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 active:scale-95 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground shadow-sm hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        \"destructive-outline\":\n          \"border border-destructive bg-transparent text-destructive hover:bg-destructive/10\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,IAAA,0KAAG,EACxB,sXACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,uBACE;YACF,SACE;YACF,WACE;YACF,OAAO;YACP,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,2KAAgB,MAC7B,QAA0D;QAAzD,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO;IACtD,MAAM,OAAO,UAAU,2KAAI,GAAG;IAC9B,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,OAAO,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/card.tsx"],"sourcesContent":["\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA;AAEA;;;;AAEA,MAAM,qBAAO,2KAAgB,MAG3B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,4DACA;QAED,GAAG,KAAK;;;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,2KAAgB,OAGjC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,2KAAgB,OAGhC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,sDACA;QAED,GAAG,KAAK;;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,2KAAgB,OAGtC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QAAI,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,2KAAgB,QAGjC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,IAAA,0KAAG,EACvB;AAGF,MAAM,sBAAQ,2KAAgB,MAI5B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,4KAAmB;QAClB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iBAAiB;QAC9B,GAAG,KAAK;;;;;;;;AAGb,MAAM,WAAW,GAAG,4KAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/form.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAC5B,QAAgC;QAA/B,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO;IAC5B,qBACE,6LAAC;QACC,MAAM;QACN,WAAW,IAAA,4HAAE,EACX,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/icons.tsx"],"sourcesContent":["import { SVGProps } from 'react';\n\nexport function Warehouse(props: SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      {...props}\n    >\n      <path d=\"M22 8.35V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8.35A2 2 0 0 1 3.17 6.5l8-4.21a2 2 0 0 1 1.66 0l8 4.21A2 2 0 0 1 22 8.35Z\" />\n      <path d=\"M6 18h12\" />\n      <path d=\"M6 14h12\" />\n      <rect width=\"12\" height=\"12\" x=\"6\" y=\"10\" />\n    </svg>\n  );\n}\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,UAAU,KAA8B;IACtD,qBACE,6LAAC;QACC,OAAM;QACN,OAAM;QACN,QAAO;QACP,SAAQ;QACR,MAAK;QACL,QAAO;QACP,aAAY;QACZ,eAAc;QACd,gBAAe;QACd,GAAG,KAAK;;0BAET,6LAAC;gBAAK,GAAE;;;;;;0BACR,6LAAC;gBAAK,GAAE;;;;;;0BACR,6LAAC;gBAAK,GAAE;;;;;;0BACR,6LAAC;gBAAK,OAAM;gBAAK,QAAO;gBAAK,GAAE;gBAAI,GAAE;;;;;;;;;;;;AAG3C;KApBgB","debugId":null}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/components/ui/skeleton.tsx"],"sourcesContent":["import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted/40\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n"],"names":[],"mappings":";;;;;AAAA;;;AAEA,SAAS,SAAS,KAGqB;QAHrB,EAChB,SAAS,EACT,GAAG,OACkC,GAHrB;IAIhB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EAAC,wCAAwC;QACrD,GAAG,KAAK;;;;;;AAGf;KAVS","debugId":null}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///home/user/tienda/src/app/register/page.tsx"],"sourcesContent":["\n\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport Link from \"next/link\";\nimport { useRouter } from \"next/navigation\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { isInitialSetupRequired, createInitialAdminUser } from \"@/lib/actions/setup\";\nimport { useToast } from \"@/hooks/use-toast\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Loader2 } from \"lucide-react\";\nimport { Warehouse } from \"@/components/icons\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\n\nconst formSchema = z.object({\n  companyName: z.string().min(2, { message: \"El nombre de la empresa es requerido.\" }),\n  adminName: z.string().min(2, { message: \"Tu nombre es requerido.\" }),\n  email: z.string().email({ message: \"Por favor, introduce un email válido.\" }),\n  password: z.string().min(6, { message: \"La contraseña debe tener al menos 6 caracteres.\" }),\n});\n\nexport default function RegisterPage() {\n  const router = useRouter();\n  const { toast } = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n  const [setupRequired, setSetupRequired] = useState<boolean | null>(null);\n\n  useEffect(() => {\n    async function checkSetup() {\n      try {\n        const required = await isInitialSetupRequired();\n        setSetupRequired(required);\n      } catch (error) {\n        console.error(\"Error checking setup status:\", error);\n        setSetupRequired(true); // Default to allowing registration if check fails.\n      }\n    }\n    checkSetup();\n  }, []);\n\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      companyName: \"\",\n      adminName: \"\",\n      email: \"\",\n      password: \"\",\n    },\n  });\n\n  async function onSubmit(values: z.infer<typeof formSchema>) {\n    setIsLoading(true);\n    try {\n      await createInitialAdminUser(values);\n\n      toast({\n        title: \"¡Empresa Registrada!\",\n        description: \"Has creado la cuenta de administrador. Ahora inicia sesión con tus nuevas credenciales.\",\n      });\n      // Redirect to login after successful registration\n      router.push(\"/login\");\n    } catch (error: any) {\n      console.error(\"Error en el registro:\", error);\n      toast({\n        variant: \"destructive\",\n        title: \"Error en el Registro\",\n        description: error.message || \"No se pudo completar el registro.\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const renderContent = () => {\n    if (setupRequired === null) {\n      return (\n        <div className=\"space-y-4 p-6\">\n          <Skeleton className=\"h-8 w-3/4\" />\n          <Skeleton className=\"h-4 w-1/2\" />\n          <div className=\"space-y-2 pt-4\">\n            <Skeleton className=\"h-10 w-full\" />\n            <Skeleton className=\"h-10 w-full\" />\n          </div>\n        </div>\n      );\n    }\n\n    // Always show the registration form.\n    return (\n        <>\n          <CardHeader className=\"text-center\">\n            <div className=\"mb-4 flex justify-center\">\n              <Warehouse className=\"h-12 w-12 text-primary\" />\n            </div>\n            <CardTitle className=\"text-2xl font-headline\">Registra tu Empresa</CardTitle>\n            <CardDescription>\n              Crea la cuenta principal de administrador para empezar a usar la aplicación.\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            <Form {...form}>\n              <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n                <FormField\n                  control={form.control}\n                  name=\"companyName\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Nombre de la Empresa</FormLabel>\n                      <FormControl><Input placeholder=\"Mi Empresa S.A.\" {...field} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                <FormField\n                  control={form.control}\n                  name=\"adminName\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Tu Nombre Completo</FormLabel>\n                      <FormControl><Input placeholder=\"Juan Pérez\" {...field} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                <FormField\n                  control={form.control}\n                  name=\"email\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Email del Administrador</FormLabel>\n                      <FormControl><Input type=\"email\" placeholder=\"admin@miempresa.com\" {...field} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                <FormField\n                  control={form.control}\n                  name=\"password\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Contraseña</FormLabel>\n                      <FormControl><Input type=\"password\" placeholder=\"••••••••\" {...field} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n                <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>\n                  {isLoading ? <Loader2 className=\"animate-spin\" /> : \"Crear Empresa y Administrador\"}\n                </Button>\n              </form>\n            </Form>\n            <div className=\"mt-4 text-center text-sm\">\n                ¿Ya tienes una cuenta?{\" \"}\n                <Link href=\"/login\" className=\"underline\">\n                Inicia Sesión\n                </Link>\n            </div>\n          </CardContent>\n        </>\n      );\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-muted/40 p-4\">\n      <Card className=\"w-full max-w-md\">{renderContent()}</Card>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}